agent: NA
Details: This was the toughest question yet (excluding q7 lol) but my completed query used a BUNCH of nested select statements in the select clause itself. The first two are self-explantory book_id and title. The nest few I use a keyword coalesce which is basically the "ifnull" statement but this time i can change the value so i put it to 0 (as the req required 0's must show up as well). for the third select statement i used count to count the reviews and joined them where the review book_id = book book_id. The fourth select is basically the same thing but this time with avg instead of count. The 5th select is almost the same but this time with the strftime, so that way we can see which dates were from 2023. Note that rdate is just a name for our column it could be named anything. Note "y" specifies we want the YEAR and the % is the wildcard operator (as seen in q2). the last select is the hardest one. here we use count but we use another select statement (so this is the third nested one) where we use UNION ALL to perfrom a FULL JOIN since sql lite doesnt support that. Note we cant do where (the 2 conditions) i tried this and it gave me WAY to many rows so we MUST use a full outer join here. And that conclcudes the query. note distinct was used to not select duplicates.  CREATE VIEW book_info AS SELECT bo.book_id, bo.title, COALESCE((SELECT COUNT(*) FROM reviews r WHERE r.book_id = bo.book_id), 0) AS revcnt,COALESCE((SELECT AVG(rating) FROM reviews r WHERE r.book_id = bo.book_id), 0) AS rating,COALESCE((SELECT AVG(rating) FROM reviews r WHERE r.book_id = bo.book_id AND strftime('%Y', rdate) = '2023'), 0) AS rating23,COALESCE((SELECT COUNT(*) FROM (SELECT book_id FROM borrowings WHERE book_id = bo.book_id UNION ALL SELECT book_id FROM waitlists WHERE book_id = bo.book_id)), 0) AS reqcnt FROM books bo; select * from book_info;
